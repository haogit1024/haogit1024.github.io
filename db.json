{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":0,"renderable":1},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":0,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0,"renderable":1}],"Cache":[{"_id":"themes/apollo/.gitignore","hash":"d6cc8c2730e89bbee83e01a5a4490f8dbf12c332","modified":1525249116479},{"_id":"themes/apollo/_config.yml","hash":"d022f22e144714bcd90b0eacdaebbec3c0817546","modified":1525250443545},{"_id":"themes/apollo/gulpfile.js","hash":"3bf61bca569665944cc61ac0483c9d568a4f58d7","modified":1525249116493},{"_id":"themes/apollo/package.json","hash":"2e81f69d66c01a6bfaacbd8bd7324b370acbed88","modified":1525249116500},{"_id":"themes/apollo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1525249116456},{"_id":"themes/apollo/.git/config","hash":"d25f78a3f0c3916281b4f0e023d2908573fcfe52","modified":1525249116468},{"_id":"themes/apollo/.git/index","hash":"839cbba31f8374cfd7ca0d0de72bf5e1b2e734ba","modified":1525250432222},{"_id":"themes/apollo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1525249109062},{"_id":"themes/apollo/LICENSE","hash":"1588511f0c37609ebfb55298b83a77ae5afca870","modified":1525249116480},{"_id":"themes/apollo/.git/packed-refs","hash":"959212f8fc97c44e0f461a8336bb6e652ddde7a6","modified":1525249116430},{"_id":"source/_posts/IOC和DI.md","hash":"6c2471aa869422341bae09274c84f1f96cf1d800","modified":1525942864312},{"_id":"source/_posts/blog.md","hash":"e447bc18798d04443e7fb6ac114a7c2e77ecd27c","modified":1524822901476},{"_id":"source/_posts/api迭代.md","hash":"a7d28831d815a9ad91bd906c8e18f9469d50826d","modified":1525311946624},{"_id":"source/_posts/debug的一些方法.md","hash":"b14da3ff7545569a99ffa82213cf4fd2e13f3c98","modified":1525772069828},{"_id":"source/_posts/事务.md","hash":"e13a2513df8ddf5ea6cbe4efcbf9ac2a73993833","modified":1526966743973},{"_id":"themes/apollo/README.md","hash":"bee45e9d6e41f6b9c01bc38f26bc60ba19c825f7","modified":1525249116491},{"_id":"source/_posts/字符和字符编码.md","hash":"ae7959db7aa80a2a990eea4e49f30d5fa6aa1154","modified":1525859809566},{"_id":"source/_posts/hello-world.md","hash":"029f91fccbe8f87c0f3ea10c4042300d2fa7edc0","modified":1524822510753},{"_id":"source/_posts/项目改造总结.md","hash":"f267af6cce2f4d1bfb21e1c0b1fe42f021507015","modified":1525228021306},{"_id":"themes/apollo/doc/doc-zh.md","hash":"6587cc3d4d826d08b1b4f678f348f08ea09fb006","modified":1525249116493},{"_id":"themes/apollo/layout/archive.jade","hash":"a993dddad0213cfc4adbf5d25597b7effac758b0","modified":1525249116495},{"_id":"themes/apollo/layout/post.jade","hash":"ada9f5f76819ff76d2c37c893431dfdb808e19b7","modified":1525249116500},{"_id":"themes/apollo/layout/index.jade","hash":"fd11746c566d9fb6de1224a2992e3e443a83c139","modified":1525249116495},{"_id":"themes/apollo/languages/en.yml","hash":"1080c108dba6b7f69c6f31633d904d85634b7ad6","modified":1525249116494},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"c6a4b8c7aaba51ffc4ea7060dca3e9a5e9f9c88f","modified":1525249116494},{"_id":"source/_posts/前后端分离的重要性.md","hash":"a5e7a65eb0bffdbcff4de89ba41866c8e94582db","modified":1525315982879},{"_id":"themes/apollo/doc/doc-en.md","hash":"d89404bf56d49e76f3129ee9fe4383861823485f","modified":1525249116492},{"_id":"themes/apollo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1525249109163},{"_id":"themes/apollo/.git/logs/HEAD","hash":"2ea57f370f1fdcb89df5c36dd10d047285a0de55","modified":1525249116459},{"_id":"themes/apollo/source/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1525249116502},{"_id":"source/_posts/编程语言强类型、弱类型、静态类型、动态类型的区别.md","hash":"4a6f134c6543b3860b001e85ded1670019ba1995","modified":1525418715081},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"47712f8bb3d84ff6a2742f923626d568779fc45a","modified":1525249116496},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"185aa2a3f86176b4924adac06ef576b365440c20","modified":1525249116498},{"_id":"themes/apollo/layout/partial/head.jade","hash":"bc1fb13056ea07b3832ed563c680ffe619d44dd9","modified":1525249116498},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"b43b1166601669cd6467bebf343efc1e5a253d64","modified":1525249116499},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"a49c19346dee6886ac8b37a1321ce170e627129a","modified":1525249116499},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"8859dd53fb511e1937179b64fecc82f61eb4b227","modified":1525249116496},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"ada3f92eb6b97263bbe562b56aeb1349a8a81fc4","modified":1525249116497},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"e309aff22fa5823aa65667cf2f189bd05adeb62a","modified":1525249116499},{"_id":"themes/apollo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1525249109076},{"_id":"themes/apollo/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1525249116503},{"_id":"themes/apollo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1525249109085},{"_id":"themes/apollo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1525249109086},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1525249116503},{"_id":"themes/apollo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1525249109084},{"_id":"themes/apollo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1525249109120},{"_id":"themes/apollo/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1525249109133},{"_id":"themes/apollo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1525249109114},{"_id":"themes/apollo/source/css/apollo.css","hash":"a9072992f3a03003fb0ada9fb2d6d76386f066ad","modified":1525249116501},{"_id":"themes/apollo/.git/refs/heads/master","hash":"bb45244afa960985b39f4bb9b86f3b4430f210ba","modified":1525249116459},{"_id":"themes/apollo/.git/objects/pack/pack-1a268874596bbc60e9ff03260917a330322bbb66.idx","hash":"c73194d9348e5fbc567365e3e35cc7bd50f13dc6","modified":1525249116125},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"bea961e9c85a0eba26b34d5568f165f48fbc9bdb","modified":1525249116508},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"3003361c281d7aa1cfed944ad0da180ac05f2c32","modified":1525249116504},{"_id":"themes/apollo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1525249109161},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"e87b144a8389eefeab4f50c353eef18c428a761c","modified":1525249116505},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"8cd2631d46be05a9518f1966bd84e1a8b0270857","modified":1525249116505},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"a6aeb5177f370f984565f7b6f0a18fe27545d34d","modified":1525249116506},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"658eef39c7cf6f730f784751c2e4701e8eb02e0d","modified":1525249116506},{"_id":"themes/apollo/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1525249109131},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"25f38fb71ade373416af569558d56e4c2e692700","modified":1525249116507},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"4ede69b12919439b4ae404a1e1d498cb8fd2932a","modified":1525249116504},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"85e5dded04b7229ab4345e53473d4e9e9cbdbfb5","modified":1525249116508},{"_id":"themes/apollo/.git/logs/refs/heads/master","hash":"2ea57f370f1fdcb89df5c36dd10d047285a0de55","modified":1525249116460},{"_id":"themes/apollo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1525249116455},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"612b367b0e9a0b9f66d37694ee64ce896c552967","modified":1525249116507},{"_id":"themes/apollo/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1525249109139},{"_id":"themes/apollo/.git/logs/refs/remotes/origin/HEAD","hash":"2ea57f370f1fdcb89df5c36dd10d047285a0de55","modified":1525249116455},{"_id":"themes/apollo/.git/objects/pack/pack-1a268874596bbc60e9ff03260917a330322bbb66.pack","hash":"1ba8b01467c6ebe1f9ec8502293bcb9e4d4d6542","modified":1525249116245},{"_id":"public/sitemap.xml","hash":"13cdb3631f4bfea4217bb78d58087f1769c6764f","modified":1526966969793},{"_id":"public/atom.xml","hash":"881a84a2be5900355b769ce96a52d53a36d5708b","modified":1526966969794},{"_id":"public/2018/05/09/字符和字符编码/index.html","hash":"097f6410ca3ad8b46730b2df699649ba572d3723","modified":1526966993308},{"_id":"public/2018/05/08/debug的一些方法/index.html","hash":"9f4487caa9b8e871411886dca155f1235d0b1615","modified":1526966993309},{"_id":"public/2018/05/04/编程语言强类型、弱类型、静态类型、动态类型的区别/index.html","hash":"c3bd91e6ca1c813f08aa0f0e65ec3f405b910e89","modified":1526966993309},{"_id":"public/2018/05/07/IOC和DI/index.html","hash":"611ab0626c4050618503a28ec56f2833a3b111e0","modified":1526966993309},{"_id":"public/2018/05/03/api迭代/index.html","hash":"3782bc31d2e863f36dfe01fd3d64e438625fbfdb","modified":1526966993309},{"_id":"public/2018/05/02/hello-world/index.html","hash":"8dde0de6d59f989614d7cdba2250f3cd0d7d0343","modified":1526966993309},{"_id":"public/2018/05/02/项目改造总结/index.html","hash":"41a5be42f6fd2152a332e57c5bb706727e4d85de","modified":1526966993309},{"_id":"public/2018/05/22/事务/index.html","hash":"0037fdba5b4e66b29d6da7a3c979a9f3ee787a50","modified":1526966993308},{"_id":"public/index.html","hash":"291e08f54d5d8868d04d75607c666dce569bf48b","modified":1526966993310},{"_id":"public/2018/04/27/blog/index.html","hash":"f7874215ca418602d6b50949e4c0f675d4cfa68c","modified":1526966993309},{"_id":"public/archives/index.html","hash":"cd820358cd85a231d3c0fb2edcb93041ae79c1cc","modified":1526966969831},{"_id":"public/2018/05/03/前后端分离的重要性/index.html","hash":"b329024420347444af80a386d6ceb82764a7ec2f","modified":1526966993309}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"IOC和DI","date":"2018-05-07T03:49:31.000Z","_content":"spring IoC是spring的核心模块之一，几乎所有的spring学习教程或资料都提倡先了解spring IoC。spring IoC贯穿整个spring框架，所有的模块都是用spring IoC container管理bean。  \n首先我们先来了解几个概念\n* 耦合度\n> 耦合度有高低之分\n* IoC https://www.zhihu.com/question/21386172?sort=created, https://my.oschina.net/zjzhai/blog/496006 , https://blog.csdn.net/qq_22654611/article/details/52606960\nIoC即Inversion of Control是控制反转的意思，这是一种设计思想（模式）。用于解耦。传统的设计：当对象A需要对象B完成某项功能，对象A会创建对象B，此时A和B耦合（A依赖B）且耦合度比较高，A还要负责控制B的生命周期。\n* DI\nDI即Dependency Injection是控制反转的意思。DI要表达的是一个过程。对象通过构造函数参数、工厂方法参数或其他初始方法\"注入\"对象，这时候注入的对象和被被注入的对象的依赖关系。其实IoC和DI是同一个意思，只是观察的角度不同产生了两种说法或者说依赖注入更加具体。  \n>ps：也有人说控制反转（Inversion of Control）括依赖注入（Dependency Injection）和依赖查找（Dependency Lookup）两个部分。依赖注入和依赖查找组成了IoC\n\n#### IoC\n我们假设一个场景：对象A需要对象B完成某项功能  \n传统的设计下：对象A会创建对象B，此时A和B耦合（A依赖B）且耦合度比较高，A还要负责控制B的生命周期。  \n而在控制反转模式下，程序员会把定义好的对象交给IoC容器同一管理，而不是在对象内部创建，此时A和B耦合（A依赖B），但是依赖程度比较低，A不需要控制B的生命周期。对于这种对对象的控制权由需求方向第三方容器的转义称为控制反转。ioc的思想最核心的地方在于，资源不由使用资源的双方管理。  \n\n上述例子我们明白了两个问题  \n1. 控制关系和控制内容：传统的程序是主动创建依赖对象，所以A控制B，而IOC模式下有专门的容器创建对象，所以控制关系是**容器控制对象**。控制的内容是**创建、销毁等生命周期**。  \n2. 什么是反转和反转内容：有反转就有正转，程序主动创建以来对象称为正转，由第三方容器创建依赖对象及注入依赖对象称为反转。所以**反转是由容器查找并注入依赖对象**，反转的内容是**依赖兑现的获取**。  \n\nIoC的核心思想是资源不由使用资源的双方管理，而由不使用资源的第三方管理。\n\n#### IOC(DI)的好处\n第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。  \n1. 资源集中管理，实现资源的可配置和易管理\n如果每个对象都是主动去创建资源，会导致资源分散难于管理，稍有不慎还会导致重复创建资源和没有正确关闭资源导致内存泄漏。\n2. 降低了使用资源双方的依赖程度，也就是我们说的耦合度\n低耦合便于书写代码和维护代码\n","source":"_posts/IOC和DI.md","raw":"---\ntitle: IOC和DI\ndate: 2018-05-07 11:49:31\ntags:\n---\nspring IoC是spring的核心模块之一，几乎所有的spring学习教程或资料都提倡先了解spring IoC。spring IoC贯穿整个spring框架，所有的模块都是用spring IoC container管理bean。  \n首先我们先来了解几个概念\n* 耦合度\n> 耦合度有高低之分\n* IoC https://www.zhihu.com/question/21386172?sort=created, https://my.oschina.net/zjzhai/blog/496006 , https://blog.csdn.net/qq_22654611/article/details/52606960\nIoC即Inversion of Control是控制反转的意思，这是一种设计思想（模式）。用于解耦。传统的设计：当对象A需要对象B完成某项功能，对象A会创建对象B，此时A和B耦合（A依赖B）且耦合度比较高，A还要负责控制B的生命周期。\n* DI\nDI即Dependency Injection是控制反转的意思。DI要表达的是一个过程。对象通过构造函数参数、工厂方法参数或其他初始方法\"注入\"对象，这时候注入的对象和被被注入的对象的依赖关系。其实IoC和DI是同一个意思，只是观察的角度不同产生了两种说法或者说依赖注入更加具体。  \n>ps：也有人说控制反转（Inversion of Control）括依赖注入（Dependency Injection）和依赖查找（Dependency Lookup）两个部分。依赖注入和依赖查找组成了IoC\n\n#### IoC\n我们假设一个场景：对象A需要对象B完成某项功能  \n传统的设计下：对象A会创建对象B，此时A和B耦合（A依赖B）且耦合度比较高，A还要负责控制B的生命周期。  \n而在控制反转模式下，程序员会把定义好的对象交给IoC容器同一管理，而不是在对象内部创建，此时A和B耦合（A依赖B），但是依赖程度比较低，A不需要控制B的生命周期。对于这种对对象的控制权由需求方向第三方容器的转义称为控制反转。ioc的思想最核心的地方在于，资源不由使用资源的双方管理。  \n\n上述例子我们明白了两个问题  \n1. 控制关系和控制内容：传统的程序是主动创建依赖对象，所以A控制B，而IOC模式下有专门的容器创建对象，所以控制关系是**容器控制对象**。控制的内容是**创建、销毁等生命周期**。  \n2. 什么是反转和反转内容：有反转就有正转，程序主动创建以来对象称为正转，由第三方容器创建依赖对象及注入依赖对象称为反转。所以**反转是由容器查找并注入依赖对象**，反转的内容是**依赖兑现的获取**。  \n\nIoC的核心思想是资源不由使用资源的双方管理，而由不使用资源的第三方管理。\n\n#### IOC(DI)的好处\n第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。  \n1. 资源集中管理，实现资源的可配置和易管理\n如果每个对象都是主动去创建资源，会导致资源分散难于管理，稍有不慎还会导致重复创建资源和没有正确关闭资源导致内存泄漏。\n2. 降低了使用资源双方的依赖程度，也就是我们说的耦合度\n低耦合便于书写代码和维护代码\n","slug":"IOC和DI","published":1,"updated":"2018-05-10T09:01:04.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhh3hgy10000r4fjrifuysvg","content":"<p>spring IoC是spring的核心模块之一，几乎所有的spring学习教程或资料都提倡先了解spring IoC。spring IoC贯穿整个spring框架，所有的模块都是用spring IoC container管理bean。<br>首先我们先来了解几个概念</p>\n<ul>\n<li>耦合度<blockquote>\n<p>耦合度有高低之分</p>\n</blockquote>\n</li>\n<li>IoC <a href=\"https://www.zhihu.com/question/21386172?sort=created\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/21386172?sort=created</a>, <a href=\"https://my.oschina.net/zjzhai/blog/496006\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/zjzhai/blog/496006</a> , <a href=\"https://blog.csdn.net/qq_22654611/article/details/52606960\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_22654611/article/details/52606960</a><br>IoC即Inversion of Control是控制反转的意思，这是一种设计思想（模式）。用于解耦。传统的设计：当对象A需要对象B完成某项功能，对象A会创建对象B，此时A和B耦合（A依赖B）且耦合度比较高，A还要负责控制B的生命周期。</li>\n<li>DI<br>DI即Dependency Injection是控制反转的意思。DI要表达的是一个过程。对象通过构造函数参数、工厂方法参数或其他初始方法”注入”对象，这时候注入的对象和被被注入的对象的依赖关系。其实IoC和DI是同一个意思，只是观察的角度不同产生了两种说法或者说依赖注入更加具体。  <blockquote>\n<p>ps：也有人说控制反转（Inversion of Control）括依赖注入（Dependency Injection）和依赖查找（Dependency Lookup）两个部分。依赖注入和依赖查找组成了IoC</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"IoC\"><a href=\"#IoC\" class=\"headerlink\" title=\"IoC\"></a>IoC</h4><p>我们假设一个场景：对象A需要对象B完成某项功能<br>传统的设计下：对象A会创建对象B，此时A和B耦合（A依赖B）且耦合度比较高，A还要负责控制B的生命周期。<br>而在控制反转模式下，程序员会把定义好的对象交给IoC容器同一管理，而不是在对象内部创建，此时A和B耦合（A依赖B），但是依赖程度比较低，A不需要控制B的生命周期。对于这种对对象的控制权由需求方向第三方容器的转义称为控制反转。ioc的思想最核心的地方在于，资源不由使用资源的双方管理。  </p>\n<p>上述例子我们明白了两个问题  </p>\n<ol>\n<li>控制关系和控制内容：传统的程序是主动创建依赖对象，所以A控制B，而IOC模式下有专门的容器创建对象，所以控制关系是<strong>容器控制对象</strong>。控制的内容是<strong>创建、销毁等生命周期</strong>。  </li>\n<li>什么是反转和反转内容：有反转就有正转，程序主动创建以来对象称为正转，由第三方容器创建依赖对象及注入依赖对象称为反转。所以<strong>反转是由容器查找并注入依赖对象</strong>，反转的内容是<strong>依赖兑现的获取</strong>。  </li>\n</ol>\n<p>IoC的核心思想是资源不由使用资源的双方管理，而由不使用资源的第三方管理。</p>\n<h4 id=\"IOC-DI-的好处\"><a href=\"#IOC-DI-的好处\" class=\"headerlink\" title=\"IOC(DI)的好处\"></a>IOC(DI)的好处</h4><p>第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。  </p>\n<ol>\n<li>资源集中管理，实现资源的可配置和易管理<br>如果每个对象都是主动去创建资源，会导致资源分散难于管理，稍有不慎还会导致重复创建资源和没有正确关闭资源导致内存泄漏。</li>\n<li>降低了使用资源双方的依赖程度，也就是我们说的耦合度<br>低耦合便于书写代码和维护代码</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>spring IoC是spring的核心模块之一，几乎所有的spring学习教程或资料都提倡先了解spring IoC。spring IoC贯穿整个spring框架，所有的模块都是用spring IoC container管理bean。<br>首先我们先来了解几个概念</p>\n<ul>\n<li>耦合度<blockquote>\n<p>耦合度有高低之分</p>\n</blockquote>\n</li>\n<li>IoC <a href=\"https://www.zhihu.com/question/21386172?sort=created\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/21386172?sort=created</a>, <a href=\"https://my.oschina.net/zjzhai/blog/496006\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/zjzhai/blog/496006</a> , <a href=\"https://blog.csdn.net/qq_22654611/article/details/52606960\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_22654611/article/details/52606960</a><br>IoC即Inversion of Control是控制反转的意思，这是一种设计思想（模式）。用于解耦。传统的设计：当对象A需要对象B完成某项功能，对象A会创建对象B，此时A和B耦合（A依赖B）且耦合度比较高，A还要负责控制B的生命周期。</li>\n<li>DI<br>DI即Dependency Injection是控制反转的意思。DI要表达的是一个过程。对象通过构造函数参数、工厂方法参数或其他初始方法”注入”对象，这时候注入的对象和被被注入的对象的依赖关系。其实IoC和DI是同一个意思，只是观察的角度不同产生了两种说法或者说依赖注入更加具体。  <blockquote>\n<p>ps：也有人说控制反转（Inversion of Control）括依赖注入（Dependency Injection）和依赖查找（Dependency Lookup）两个部分。依赖注入和依赖查找组成了IoC</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"IoC\"><a href=\"#IoC\" class=\"headerlink\" title=\"IoC\"></a>IoC</h4><p>我们假设一个场景：对象A需要对象B完成某项功能<br>传统的设计下：对象A会创建对象B，此时A和B耦合（A依赖B）且耦合度比较高，A还要负责控制B的生命周期。<br>而在控制反转模式下，程序员会把定义好的对象交给IoC容器同一管理，而不是在对象内部创建，此时A和B耦合（A依赖B），但是依赖程度比较低，A不需要控制B的生命周期。对于这种对对象的控制权由需求方向第三方容器的转义称为控制反转。ioc的思想最核心的地方在于，资源不由使用资源的双方管理。  </p>\n<p>上述例子我们明白了两个问题  </p>\n<ol>\n<li>控制关系和控制内容：传统的程序是主动创建依赖对象，所以A控制B，而IOC模式下有专门的容器创建对象，所以控制关系是<strong>容器控制对象</strong>。控制的内容是<strong>创建、销毁等生命周期</strong>。  </li>\n<li>什么是反转和反转内容：有反转就有正转，程序主动创建以来对象称为正转，由第三方容器创建依赖对象及注入依赖对象称为反转。所以<strong>反转是由容器查找并注入依赖对象</strong>，反转的内容是<strong>依赖兑现的获取</strong>。  </li>\n</ol>\n<p>IoC的核心思想是资源不由使用资源的双方管理，而由不使用资源的第三方管理。</p>\n<h4 id=\"IOC-DI-的好处\"><a href=\"#IOC-DI-的好处\" class=\"headerlink\" title=\"IOC(DI)的好处\"></a>IOC(DI)的好处</h4><p>第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。  </p>\n<ol>\n<li>资源集中管理，实现资源的可配置和易管理<br>如果每个对象都是主动去创建资源，会导致资源分散难于管理，稍有不慎还会导致重复创建资源和没有正确关闭资源导致内存泄漏。</li>\n<li>降低了使用资源双方的依赖程度，也就是我们说的耦合度<br>低耦合便于书写代码和维护代码</li>\n</ol>\n"},{"title":"blog","date":"2018-04-27T09:54:48.000Z","_content":"this is my blog","source":"_posts/blog.md","raw":"---\ntitle: blog\ndate: 2018-04-27 17:54:48\ntags:\n---\nthis is my blog","slug":"blog","published":1,"updated":"2018-04-27T09:55:01.476Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhh3hgya0001r4fjebx8jn57","content":"<p>this is my blog</p>\n","site":{"data":{}},"excerpt":"","more":"<p>this is my blog</p>\n"},{"title":"api迭代","date":"2018-05-03T01:06:28.000Z","_content":"\n### API迭代总结\n\n1. 升级要兼容旧版接口\n2. 坚持开闭原则(扩展开放，对修改关闭)\n3. 代码要符合最新定义的协议，不能存在部分没有升级的情况\n4. 注意生产环境和开发环境的代码和数据同步问题\n\n","source":"_posts/api迭代.md","raw":"---\ntitle: api迭代\ndate: 2018-05-03 09:06:28\ntags:\n---\n\n### API迭代总结\n\n1. 升级要兼容旧版接口\n2. 坚持开闭原则(扩展开放，对修改关闭)\n3. 代码要符合最新定义的协议，不能存在部分没有升级的情况\n4. 注意生产环境和开发环境的代码和数据同步问题\n\n","slug":"api迭代","published":1,"updated":"2018-05-03T01:45:46.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhh3hgyh0002r4fjeml5u6qo","content":"<h3 id=\"API迭代总结\"><a href=\"#API迭代总结\" class=\"headerlink\" title=\"API迭代总结\"></a>API迭代总结</h3><ol>\n<li>升级要兼容旧版接口</li>\n<li>坚持开闭原则(扩展开放，对修改关闭)</li>\n<li>代码要符合最新定义的协议，不能存在部分没有升级的情况</li>\n<li>注意生产环境和开发环境的代码和数据同步问题</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"API迭代总结\"><a href=\"#API迭代总结\" class=\"headerlink\" title=\"API迭代总结\"></a>API迭代总结</h3><ol>\n<li>升级要兼容旧版接口</li>\n<li>坚持开闭原则(扩展开放，对修改关闭)</li>\n<li>代码要符合最新定义的协议，不能存在部分没有升级的情况</li>\n<li>注意生产环境和开发环境的代码和数据同步问题</li>\n</ol>\n"},{"title":"debug的一些方法","date":"2018-05-08T09:28:33.000Z","_content":"### debug的一些方法\n**线面方法部分前后顺序**\n1. 确认问题的具体信息\n>出现问题时一定要尽可能的收集错误信息，便于追踪问题\n2. 查找日志\n>在日志中查找出现问题的地方\n3. 重现问题\n>只有重现问题的时候才能调试。尝试修复bug后，通过重现问题检测bug修复情况\n","source":"_posts/debug的一些方法.md","raw":"---\ntitle: debug的一些方法\ndate: 2018-05-08 17:28:33\ntags:\n---\n### debug的一些方法\n**线面方法部分前后顺序**\n1. 确认问题的具体信息\n>出现问题时一定要尽可能的收集错误信息，便于追踪问题\n2. 查找日志\n>在日志中查找出现问题的地方\n3. 重现问题\n>只有重现问题的时候才能调试。尝试修复bug后，通过重现问题检测bug修复情况\n","slug":"debug的一些方法","published":1,"updated":"2018-05-08T09:34:29.828Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhh3hgyj0003r4fj39ne8ln1","content":"<h3 id=\"debug的一些方法\"><a href=\"#debug的一些方法\" class=\"headerlink\" title=\"debug的一些方法\"></a>debug的一些方法</h3><p><strong>线面方法部分前后顺序</strong></p>\n<ol>\n<li>确认问题的具体信息<blockquote>\n<p>出现问题时一定要尽可能的收集错误信息，便于追踪问题</p>\n</blockquote>\n</li>\n<li>查找日志<blockquote>\n<p>在日志中查找出现问题的地方</p>\n</blockquote>\n</li>\n<li>重现问题<blockquote>\n<p>只有重现问题的时候才能调试。尝试修复bug后，通过重现问题检测bug修复情况</p>\n</blockquote>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"debug的一些方法\"><a href=\"#debug的一些方法\" class=\"headerlink\" title=\"debug的一些方法\"></a>debug的一些方法</h3><p><strong>线面方法部分前后顺序</strong></p>\n<ol>\n<li>确认问题的具体信息<blockquote>\n<p>出现问题时一定要尽可能的收集错误信息，便于追踪问题</p>\n</blockquote>\n</li>\n<li>查找日志<blockquote>\n<p>在日志中查找出现问题的地方</p>\n</blockquote>\n</li>\n<li>重现问题<blockquote>\n<p>只有重现问题的时候才能调试。尝试修复bug后，通过重现问题检测bug修复情况</p>\n</blockquote>\n</li>\n</ol>\n"},{"title":"事务","date":"2018-05-22T02:36:29.000Z","_content":"#### 首先先复习一下事务的基本知识\n##### 事务介绍\n事务（Transaction），在计算机中一般指对数据库众各种数据项的一个程序执行单元（对数据库的一组操作）。通过事务可以保证一个执行单元内的操作都成功时才更新数据的数据项，否则不会更新数据库。即我们常说的要么全部成功，要么全部失败。  \n\n##### 事务的四个特性\n* 原子性（Atomic）\n>原子在物理上是不可分割的，表示事务内的操作也是不可分割的，是一体的，所以原子性是指事务要么全部成功，要么全部失败。\n* 一致性\n> 忘了，回去翻书。大致上是指事务执行是从一个一致性状态转为另一个一致性状态\n* 隔离性\n> 在并发过程中，可能会有多个事务在处理形同的数据。事务之间不能互相干扰，多个事务之间要互相隔离\n* 持久性\n> 持久性是指事务提交后，对数据库的修改是永久性的  \n\n##### 多个事务并发带来的问题\n* 脏读（Dirty reads）\n> 指一个事务读取到另一个事务修改但未提交的数据。如果修改数据事务回滚会导致读取数据事务获取到错误数据\n* 不可重复读（Nonrepeatable read）\n> 指一个事务内对同一个数据进行多次查询的到不同的结果。通常是查询间隔期间其他事务修改导致\n* 幻读（Phantom read）\n> 与不可重复读类似。指一个事务对一些数据的多次查询得到的数量不一致。通常是查询间隔期间其他事务插入或删除数据导致   \n\n**PS：不可重复读重点是修改，幻读重点是插入和删除**\n\n##### 事务隔离\n事务隔离和并发控制类似，都是通过锁来实现的\n**数据库中的各种锁我就不介绍了，用兴趣的同学可以自己找一下资料，这里只介绍数据库中常见的事务隔离级别**\n|事务级别|脏读|不可重复读|幻读|\n|---|:---:|---:|---:|\n|READ_UNCOMMITTED|允许|允许|允许|\n|READ_COMMITTED|禁止|允许|允许|\n|REPEATABLE_READ|禁止|禁止|允许|\n|SERIALIZABLE|禁止|禁止|禁止|\nMySQL默认的事务级别是READ_COMMITTED  \n\nps：除了数据库的事务级别外，各种库和框架还实现了一些关于事务的其他功能。例如JDBC的数据隔离级别，spirng的事务传播和spirng自己的事务隔离级别。无论是数据库实现还是库、框架实现的功能都是程序员平时需要用到的  \n\n**上面这些都是数据库实现的，下面是实践和代码层面的知识**\n\n#### spring中的事务（未完待续）\n##### spring事务传播\n##### spring事务隔离级别\n##### spring编程式事务和生明式事务\n##### \n","source":"_posts/事务.md","raw":"---\ntitle: 事务\ndate: 2018-05-22 10:36:29\ntags:\n---\n#### 首先先复习一下事务的基本知识\n##### 事务介绍\n事务（Transaction），在计算机中一般指对数据库众各种数据项的一个程序执行单元（对数据库的一组操作）。通过事务可以保证一个执行单元内的操作都成功时才更新数据的数据项，否则不会更新数据库。即我们常说的要么全部成功，要么全部失败。  \n\n##### 事务的四个特性\n* 原子性（Atomic）\n>原子在物理上是不可分割的，表示事务内的操作也是不可分割的，是一体的，所以原子性是指事务要么全部成功，要么全部失败。\n* 一致性\n> 忘了，回去翻书。大致上是指事务执行是从一个一致性状态转为另一个一致性状态\n* 隔离性\n> 在并发过程中，可能会有多个事务在处理形同的数据。事务之间不能互相干扰，多个事务之间要互相隔离\n* 持久性\n> 持久性是指事务提交后，对数据库的修改是永久性的  \n\n##### 多个事务并发带来的问题\n* 脏读（Dirty reads）\n> 指一个事务读取到另一个事务修改但未提交的数据。如果修改数据事务回滚会导致读取数据事务获取到错误数据\n* 不可重复读（Nonrepeatable read）\n> 指一个事务内对同一个数据进行多次查询的到不同的结果。通常是查询间隔期间其他事务修改导致\n* 幻读（Phantom read）\n> 与不可重复读类似。指一个事务对一些数据的多次查询得到的数量不一致。通常是查询间隔期间其他事务插入或删除数据导致   \n\n**PS：不可重复读重点是修改，幻读重点是插入和删除**\n\n##### 事务隔离\n事务隔离和并发控制类似，都是通过锁来实现的\n**数据库中的各种锁我就不介绍了，用兴趣的同学可以自己找一下资料，这里只介绍数据库中常见的事务隔离级别**\n|事务级别|脏读|不可重复读|幻读|\n|---|:---:|---:|---:|\n|READ_UNCOMMITTED|允许|允许|允许|\n|READ_COMMITTED|禁止|允许|允许|\n|REPEATABLE_READ|禁止|禁止|允许|\n|SERIALIZABLE|禁止|禁止|禁止|\nMySQL默认的事务级别是READ_COMMITTED  \n\nps：除了数据库的事务级别外，各种库和框架还实现了一些关于事务的其他功能。例如JDBC的数据隔离级别，spirng的事务传播和spirng自己的事务隔离级别。无论是数据库实现还是库、框架实现的功能都是程序员平时需要用到的  \n\n**上面这些都是数据库实现的，下面是实践和代码层面的知识**\n\n#### spring中的事务（未完待续）\n##### spring事务传播\n##### spring事务隔离级别\n##### spring编程式事务和生明式事务\n##### \n","slug":"事务","published":1,"updated":"2018-05-22T05:25:43.973Z","_id":"cjhh3hh7u0004r4fjru2xoz7q","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"首先先复习一下事务的基本知识\"><a href=\"#首先先复习一下事务的基本知识\" class=\"headerlink\" title=\"首先先复习一下事务的基本知识\"></a>首先先复习一下事务的基本知识</h4><h5 id=\"事务介绍\"><a href=\"#事务介绍\" class=\"headerlink\" title=\"事务介绍\"></a>事务介绍</h5><p>事务（Transaction），在计算机中一般指对数据库众各种数据项的一个程序执行单元（对数据库的一组操作）。通过事务可以保证一个执行单元内的操作都成功时才更新数据的数据项，否则不会更新数据库。即我们常说的要么全部成功，要么全部失败。  </p>\n<h5 id=\"事务的四个特性\"><a href=\"#事务的四个特性\" class=\"headerlink\" title=\"事务的四个特性\"></a>事务的四个特性</h5><ul>\n<li>原子性（Atomic）<blockquote>\n<p>原子在物理上是不可分割的，表示事务内的操作也是不可分割的，是一体的，所以原子性是指事务要么全部成功，要么全部失败。</p>\n</blockquote>\n</li>\n<li>一致性<blockquote>\n<p>忘了，回去翻书。大致上是指事务执行是从一个一致性状态转为另一个一致性状态</p>\n</blockquote>\n</li>\n<li>隔离性<blockquote>\n<p>在并发过程中，可能会有多个事务在处理形同的数据。事务之间不能互相干扰，多个事务之间要互相隔离</p>\n</blockquote>\n</li>\n<li>持久性<blockquote>\n<p>持久性是指事务提交后，对数据库的修改是永久性的  </p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"多个事务并发带来的问题\"><a href=\"#多个事务并发带来的问题\" class=\"headerlink\" title=\"多个事务并发带来的问题\"></a>多个事务并发带来的问题</h5><ul>\n<li>脏读（Dirty reads）<blockquote>\n<p>指一个事务读取到另一个事务修改但未提交的数据。如果修改数据事务回滚会导致读取数据事务获取到错误数据</p>\n</blockquote>\n</li>\n<li>不可重复读（Nonrepeatable read）<blockquote>\n<p>指一个事务内对同一个数据进行多次查询的到不同的结果。通常是查询间隔期间其他事务修改导致</p>\n</blockquote>\n</li>\n<li>幻读（Phantom read）<blockquote>\n<p>与不可重复读类似。指一个事务对一些数据的多次查询得到的数量不一致。通常是查询间隔期间其他事务插入或删除数据导致   </p>\n</blockquote>\n</li>\n</ul>\n<p><strong>PS：不可重复读重点是修改，幻读重点是插入和删除</strong></p>\n<h5 id=\"事务隔离\"><a href=\"#事务隔离\" class=\"headerlink\" title=\"事务隔离\"></a>事务隔离</h5><p>事务隔离和并发控制类似，都是通过锁来实现的<br><strong>数据库中的各种锁我就不介绍了，用兴趣的同学可以自己找一下资料，这里只介绍数据库中常见的事务隔离级别</strong><br>|事务级别|脏读|不可重复读|幻读|<br>|—|:—:|—:|—:|<br>|READ_UNCOMMITTED|允许|允许|允许|<br>|READ_COMMITTED|禁止|允许|允许|<br>|REPEATABLE_READ|禁止|禁止|允许|<br>|SERIALIZABLE|禁止|禁止|禁止|<br>MySQL默认的事务级别是READ_COMMITTED  </p>\n<p>ps：除了数据库的事务级别外，各种库和框架还实现了一些关于事务的其他功能。例如JDBC的数据隔离级别，spirng的事务传播和spirng自己的事务隔离级别。无论是数据库实现还是库、框架实现的功能都是程序员平时需要用到的  </p>\n<p><strong>上面这些都是数据库实现的，下面是实践和代码层面的知识</strong></p>\n<h4 id=\"spring中的事务（未完待续）\"><a href=\"#spring中的事务（未完待续）\" class=\"headerlink\" title=\"spring中的事务（未完待续）\"></a>spring中的事务（未完待续）</h4><h5 id=\"spring事务传播\"><a href=\"#spring事务传播\" class=\"headerlink\" title=\"spring事务传播\"></a>spring事务传播</h5><h5 id=\"spring事务隔离级别\"><a href=\"#spring事务隔离级别\" class=\"headerlink\" title=\"spring事务隔离级别\"></a>spring事务隔离级别</h5><h5 id=\"spring编程式事务和生明式事务\"><a href=\"#spring编程式事务和生明式事务\" class=\"headerlink\" title=\"spring编程式事务和生明式事务\"></a>spring编程式事务和生明式事务</h5><p>##### </p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"首先先复习一下事务的基本知识\"><a href=\"#首先先复习一下事务的基本知识\" class=\"headerlink\" title=\"首先先复习一下事务的基本知识\"></a>首先先复习一下事务的基本知识</h4><h5 id=\"事务介绍\"><a href=\"#事务介绍\" class=\"headerlink\" title=\"事务介绍\"></a>事务介绍</h5><p>事务（Transaction），在计算机中一般指对数据库众各种数据项的一个程序执行单元（对数据库的一组操作）。通过事务可以保证一个执行单元内的操作都成功时才更新数据的数据项，否则不会更新数据库。即我们常说的要么全部成功，要么全部失败。  </p>\n<h5 id=\"事务的四个特性\"><a href=\"#事务的四个特性\" class=\"headerlink\" title=\"事务的四个特性\"></a>事务的四个特性</h5><ul>\n<li>原子性（Atomic）<blockquote>\n<p>原子在物理上是不可分割的，表示事务内的操作也是不可分割的，是一体的，所以原子性是指事务要么全部成功，要么全部失败。</p>\n</blockquote>\n</li>\n<li>一致性<blockquote>\n<p>忘了，回去翻书。大致上是指事务执行是从一个一致性状态转为另一个一致性状态</p>\n</blockquote>\n</li>\n<li>隔离性<blockquote>\n<p>在并发过程中，可能会有多个事务在处理形同的数据。事务之间不能互相干扰，多个事务之间要互相隔离</p>\n</blockquote>\n</li>\n<li>持久性<blockquote>\n<p>持久性是指事务提交后，对数据库的修改是永久性的  </p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"多个事务并发带来的问题\"><a href=\"#多个事务并发带来的问题\" class=\"headerlink\" title=\"多个事务并发带来的问题\"></a>多个事务并发带来的问题</h5><ul>\n<li>脏读（Dirty reads）<blockquote>\n<p>指一个事务读取到另一个事务修改但未提交的数据。如果修改数据事务回滚会导致读取数据事务获取到错误数据</p>\n</blockquote>\n</li>\n<li>不可重复读（Nonrepeatable read）<blockquote>\n<p>指一个事务内对同一个数据进行多次查询的到不同的结果。通常是查询间隔期间其他事务修改导致</p>\n</blockquote>\n</li>\n<li>幻读（Phantom read）<blockquote>\n<p>与不可重复读类似。指一个事务对一些数据的多次查询得到的数量不一致。通常是查询间隔期间其他事务插入或删除数据导致   </p>\n</blockquote>\n</li>\n</ul>\n<p><strong>PS：不可重复读重点是修改，幻读重点是插入和删除</strong></p>\n<h5 id=\"事务隔离\"><a href=\"#事务隔离\" class=\"headerlink\" title=\"事务隔离\"></a>事务隔离</h5><p>事务隔离和并发控制类似，都是通过锁来实现的<br><strong>数据库中的各种锁我就不介绍了，用兴趣的同学可以自己找一下资料，这里只介绍数据库中常见的事务隔离级别</strong><br>|事务级别|脏读|不可重复读|幻读|<br>|—|:—:|—:|—:|<br>|READ_UNCOMMITTED|允许|允许|允许|<br>|READ_COMMITTED|禁止|允许|允许|<br>|REPEATABLE_READ|禁止|禁止|允许|<br>|SERIALIZABLE|禁止|禁止|禁止|<br>MySQL默认的事务级别是READ_COMMITTED  </p>\n<p>ps：除了数据库的事务级别外，各种库和框架还实现了一些关于事务的其他功能。例如JDBC的数据隔离级别，spirng的事务传播和spirng自己的事务隔离级别。无论是数据库实现还是库、框架实现的功能都是程序员平时需要用到的  </p>\n<p><strong>上面这些都是数据库实现的，下面是实践和代码层面的知识</strong></p>\n<h4 id=\"spring中的事务（未完待续）\"><a href=\"#spring中的事务（未完待续）\" class=\"headerlink\" title=\"spring中的事务（未完待续）\"></a>spring中的事务（未完待续）</h4><h5 id=\"spring事务传播\"><a href=\"#spring事务传播\" class=\"headerlink\" title=\"spring事务传播\"></a>spring事务传播</h5><h5 id=\"spring事务隔离级别\"><a href=\"#spring事务隔离级别\" class=\"headerlink\" title=\"spring事务隔离级别\"></a>spring事务隔离级别</h5><h5 id=\"spring编程式事务和生明式事务\"><a href=\"#spring编程式事务和生明式事务\" class=\"headerlink\" title=\"spring编程式事务和生明式事务\"></a>spring编程式事务和生明式事务</h5><p>##### </p>\n"},{"title":"字符和字符编码","date":"2018-05-09T09:56:49.000Z","_content":"","source":"_posts/字符和字符编码.md","raw":"---\ntitle: 字符和字符编码\ndate: 2018-05-09 17:56:49\ntags:\n---\n","slug":"字符和字符编码","published":1,"updated":"2018-05-09T09:56:49.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhh3hh7y0005r4fjdbouta1i","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-05-02T01:39:28.651Z","updated":"2018-04-27T09:48:30.753Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhh3hh800006r4fjc0n43va5","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"项目改造总结","date":"2018-05-02T01:51:30.000Z","_content":"\n### 项目改造总结了几点经验\n1. 项目开始尽可能想到更多方面 \n2. 尽可能不要硬编码  \n3. 层次尽可能清晰   \n4. 实体关联关系一定要明确且不要随便乱改实体关联关系\n\n#### 项目开始尽可能想到更多方面 \n根据代码大全的建议，项目开始之前想的越周到越好。在项目进行中修改项目架构和数据接口(添加表或者修改表之间的关系)都会早成项目管理混乱和代码混乱。例如：为了兼容和适应新的数据库表关系，代码中会出现很多兼容代码。这些代码看起来会很奇怪，可读性较差，增加维护难度。  \n\n#### 尽可能不要硬编码 \n这应该是基本要求了。一定要注意代码封装，写新的业务逻辑的时候，代码从高层向下一层一层抽象，例如：先抽象出controller, controller包含了整合业务的逻辑, 根据controller的要求去调用或写service, 然后service去调用或写dao。切记不能在写controller的时候碰到一个操作就转过去写service或dao, 应该先把controller写完。service同理, 先写完service再写dao。这是写新业务的方法, 在项目开始的时候，应该要先写一些可能用到的dao和service。\n\n#### 层次尽可能清晰\n代码一定要分层，层次要清晰，层与层之间的调用关系不能乱。\n\n#### 实体关联关系一定要明确且不要随便乱改实体关联关系\n更改实体关系，会产生一部分旧数据用的是以前的关联关系。更改实体关联关系相当于重构一部分功能。因为要兼容旧数据，会导致代码混乱","source":"_posts/项目改造总结.md","raw":"---\ntitle: 项目改造总结\ndate: 2018-05-02 09:51:30\ntags:\n---\n\n### 项目改造总结了几点经验\n1. 项目开始尽可能想到更多方面 \n2. 尽可能不要硬编码  \n3. 层次尽可能清晰   \n4. 实体关联关系一定要明确且不要随便乱改实体关联关系\n\n#### 项目开始尽可能想到更多方面 \n根据代码大全的建议，项目开始之前想的越周到越好。在项目进行中修改项目架构和数据接口(添加表或者修改表之间的关系)都会早成项目管理混乱和代码混乱。例如：为了兼容和适应新的数据库表关系，代码中会出现很多兼容代码。这些代码看起来会很奇怪，可读性较差，增加维护难度。  \n\n#### 尽可能不要硬编码 \n这应该是基本要求了。一定要注意代码封装，写新的业务逻辑的时候，代码从高层向下一层一层抽象，例如：先抽象出controller, controller包含了整合业务的逻辑, 根据controller的要求去调用或写service, 然后service去调用或写dao。切记不能在写controller的时候碰到一个操作就转过去写service或dao, 应该先把controller写完。service同理, 先写完service再写dao。这是写新业务的方法, 在项目开始的时候，应该要先写一些可能用到的dao和service。\n\n#### 层次尽可能清晰\n代码一定要分层，层次要清晰，层与层之间的调用关系不能乱。\n\n#### 实体关联关系一定要明确且不要随便乱改实体关联关系\n更改实体关系，会产生一部分旧数据用的是以前的关联关系。更改实体关联关系相当于重构一部分功能。因为要兼容旧数据，会导致代码混乱","slug":"项目改造总结","published":1,"updated":"2018-05-02T02:27:01.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhh3hh820007r4fjddr83q9y","content":"<h3 id=\"项目改造总结了几点经验\"><a href=\"#项目改造总结了几点经验\" class=\"headerlink\" title=\"项目改造总结了几点经验\"></a>项目改造总结了几点经验</h3><ol>\n<li>项目开始尽可能想到更多方面 </li>\n<li>尽可能不要硬编码  </li>\n<li>层次尽可能清晰   </li>\n<li>实体关联关系一定要明确且不要随便乱改实体关联关系</li>\n</ol>\n<h4 id=\"项目开始尽可能想到更多方面\"><a href=\"#项目开始尽可能想到更多方面\" class=\"headerlink\" title=\"项目开始尽可能想到更多方面\"></a>项目开始尽可能想到更多方面</h4><p>根据代码大全的建议，项目开始之前想的越周到越好。在项目进行中修改项目架构和数据接口(添加表或者修改表之间的关系)都会早成项目管理混乱和代码混乱。例如：为了兼容和适应新的数据库表关系，代码中会出现很多兼容代码。这些代码看起来会很奇怪，可读性较差，增加维护难度。  </p>\n<h4 id=\"尽可能不要硬编码\"><a href=\"#尽可能不要硬编码\" class=\"headerlink\" title=\"尽可能不要硬编码\"></a>尽可能不要硬编码</h4><p>这应该是基本要求了。一定要注意代码封装，写新的业务逻辑的时候，代码从高层向下一层一层抽象，例如：先抽象出controller, controller包含了整合业务的逻辑, 根据controller的要求去调用或写service, 然后service去调用或写dao。切记不能在写controller的时候碰到一个操作就转过去写service或dao, 应该先把controller写完。service同理, 先写完service再写dao。这是写新业务的方法, 在项目开始的时候，应该要先写一些可能用到的dao和service。</p>\n<h4 id=\"层次尽可能清晰\"><a href=\"#层次尽可能清晰\" class=\"headerlink\" title=\"层次尽可能清晰\"></a>层次尽可能清晰</h4><p>代码一定要分层，层次要清晰，层与层之间的调用关系不能乱。</p>\n<h4 id=\"实体关联关系一定要明确且不要随便乱改实体关联关系\"><a href=\"#实体关联关系一定要明确且不要随便乱改实体关联关系\" class=\"headerlink\" title=\"实体关联关系一定要明确且不要随便乱改实体关联关系\"></a>实体关联关系一定要明确且不要随便乱改实体关联关系</h4><p>更改实体关系，会产生一部分旧数据用的是以前的关联关系。更改实体关联关系相当于重构一部分功能。因为要兼容旧数据，会导致代码混乱</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"项目改造总结了几点经验\"><a href=\"#项目改造总结了几点经验\" class=\"headerlink\" title=\"项目改造总结了几点经验\"></a>项目改造总结了几点经验</h3><ol>\n<li>项目开始尽可能想到更多方面 </li>\n<li>尽可能不要硬编码  </li>\n<li>层次尽可能清晰   </li>\n<li>实体关联关系一定要明确且不要随便乱改实体关联关系</li>\n</ol>\n<h4 id=\"项目开始尽可能想到更多方面\"><a href=\"#项目开始尽可能想到更多方面\" class=\"headerlink\" title=\"项目开始尽可能想到更多方面\"></a>项目开始尽可能想到更多方面</h4><p>根据代码大全的建议，项目开始之前想的越周到越好。在项目进行中修改项目架构和数据接口(添加表或者修改表之间的关系)都会早成项目管理混乱和代码混乱。例如：为了兼容和适应新的数据库表关系，代码中会出现很多兼容代码。这些代码看起来会很奇怪，可读性较差，增加维护难度。  </p>\n<h4 id=\"尽可能不要硬编码\"><a href=\"#尽可能不要硬编码\" class=\"headerlink\" title=\"尽可能不要硬编码\"></a>尽可能不要硬编码</h4><p>这应该是基本要求了。一定要注意代码封装，写新的业务逻辑的时候，代码从高层向下一层一层抽象，例如：先抽象出controller, controller包含了整合业务的逻辑, 根据controller的要求去调用或写service, 然后service去调用或写dao。切记不能在写controller的时候碰到一个操作就转过去写service或dao, 应该先把controller写完。service同理, 先写完service再写dao。这是写新业务的方法, 在项目开始的时候，应该要先写一些可能用到的dao和service。</p>\n<h4 id=\"层次尽可能清晰\"><a href=\"#层次尽可能清晰\" class=\"headerlink\" title=\"层次尽可能清晰\"></a>层次尽可能清晰</h4><p>代码一定要分层，层次要清晰，层与层之间的调用关系不能乱。</p>\n<h4 id=\"实体关联关系一定要明确且不要随便乱改实体关联关系\"><a href=\"#实体关联关系一定要明确且不要随便乱改实体关联关系\" class=\"headerlink\" title=\"实体关联关系一定要明确且不要随便乱改实体关联关系\"></a>实体关联关系一定要明确且不要随便乱改实体关联关系</h4><p>更改实体关系，会产生一部分旧数据用的是以前的关联关系。更改实体关联关系相当于重构一部分功能。因为要兼容旧数据，会导致代码混乱</p>\n"},{"title":"前后端分离的重要性","date":"2018-05-03T02:18:49.000Z","_content":"\n### 前后端分离的意义和重要性（待完善）\n\n#### 技术方面\n1. 前后端分开迭代，前端或后端需要频繁迭代时不影响另一端（修改数据逻辑不影响显示逻辑）\n1. 分离数据逻辑和表现逻辑(前后端耦合容易造成数据逻辑与表现逻辑混杂不清,这点在debug的时候尤其痛苦)\n1. 展示类，管理类（CMS）项目强烈建议前后端分离\n1. 前后端解耦方便维护（解耦有多重要就不多说了）。后端专注于提供数据，维护系统稳定，保证数据安全可靠（数据逻辑）。前端专注于交互和ui（表现逻辑）\n1. 可以个APP端和web端提供统一的接口（同样的业务逻辑如果要写N遍，头疼，debug或加功能还要加N遍，心烦）\n\n#### 人员方面\n1. 可以让每个员工变的更加专注，发挥TA自己最大的能力。前后端分离是为了更好的协作，在组织和流程上更加容易管理和达到更高的效率\n2. 技术人员往往只能精通一个方面的技术（靠谱的全栈工程师还是少，或者说全栈工程师只是某个技术栈的全栈工程师）\n\n#### 综合方面\n1. 前后端分离对人员和技术的要求更低\n\n**前后端分离是指技术架构上的分离，而不是组织/流程、职位/工种的分离**","source":"_posts/前后端分离的重要性.md","raw":"---\ntitle: 前后端分离的重要性\ndate: 2018-05-03 10:18:49\ntags:\n---\n\n### 前后端分离的意义和重要性（待完善）\n\n#### 技术方面\n1. 前后端分开迭代，前端或后端需要频繁迭代时不影响另一端（修改数据逻辑不影响显示逻辑）\n1. 分离数据逻辑和表现逻辑(前后端耦合容易造成数据逻辑与表现逻辑混杂不清,这点在debug的时候尤其痛苦)\n1. 展示类，管理类（CMS）项目强烈建议前后端分离\n1. 前后端解耦方便维护（解耦有多重要就不多说了）。后端专注于提供数据，维护系统稳定，保证数据安全可靠（数据逻辑）。前端专注于交互和ui（表现逻辑）\n1. 可以个APP端和web端提供统一的接口（同样的业务逻辑如果要写N遍，头疼，debug或加功能还要加N遍，心烦）\n\n#### 人员方面\n1. 可以让每个员工变的更加专注，发挥TA自己最大的能力。前后端分离是为了更好的协作，在组织和流程上更加容易管理和达到更高的效率\n2. 技术人员往往只能精通一个方面的技术（靠谱的全栈工程师还是少，或者说全栈工程师只是某个技术栈的全栈工程师）\n\n#### 综合方面\n1. 前后端分离对人员和技术的要求更低\n\n**前后端分离是指技术架构上的分离，而不是组织/流程、职位/工种的分离**","slug":"前后端分离的重要性","published":1,"updated":"2018-05-03T02:53:02.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhh3hh830008r4fj1q3ykyii","content":"<h3 id=\"前后端分离的意义和重要性（待完善）\"><a href=\"#前后端分离的意义和重要性（待完善）\" class=\"headerlink\" title=\"前后端分离的意义和重要性（待完善）\"></a>前后端分离的意义和重要性（待完善）</h3><h4 id=\"技术方面\"><a href=\"#技术方面\" class=\"headerlink\" title=\"技术方面\"></a>技术方面</h4><ol>\n<li>前后端分开迭代，前端或后端需要频繁迭代时不影响另一端（修改数据逻辑不影响显示逻辑）</li>\n<li>分离数据逻辑和表现逻辑(前后端耦合容易造成数据逻辑与表现逻辑混杂不清,这点在debug的时候尤其痛苦)</li>\n<li>展示类，管理类（CMS）项目强烈建议前后端分离</li>\n<li>前后端解耦方便维护（解耦有多重要就不多说了）。后端专注于提供数据，维护系统稳定，保证数据安全可靠（数据逻辑）。前端专注于交互和ui（表现逻辑）</li>\n<li>可以个APP端和web端提供统一的接口（同样的业务逻辑如果要写N遍，头疼，debug或加功能还要加N遍，心烦）</li>\n</ol>\n<h4 id=\"人员方面\"><a href=\"#人员方面\" class=\"headerlink\" title=\"人员方面\"></a>人员方面</h4><ol>\n<li>可以让每个员工变的更加专注，发挥TA自己最大的能力。前后端分离是为了更好的协作，在组织和流程上更加容易管理和达到更高的效率</li>\n<li>技术人员往往只能精通一个方面的技术（靠谱的全栈工程师还是少，或者说全栈工程师只是某个技术栈的全栈工程师）</li>\n</ol>\n<h4 id=\"综合方面\"><a href=\"#综合方面\" class=\"headerlink\" title=\"综合方面\"></a>综合方面</h4><ol>\n<li>前后端分离对人员和技术的要求更低</li>\n</ol>\n<p><strong>前后端分离是指技术架构上的分离，而不是组织/流程、职位/工种的分离</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前后端分离的意义和重要性（待完善）\"><a href=\"#前后端分离的意义和重要性（待完善）\" class=\"headerlink\" title=\"前后端分离的意义和重要性（待完善）\"></a>前后端分离的意义和重要性（待完善）</h3><h4 id=\"技术方面\"><a href=\"#技术方面\" class=\"headerlink\" title=\"技术方面\"></a>技术方面</h4><ol>\n<li>前后端分开迭代，前端或后端需要频繁迭代时不影响另一端（修改数据逻辑不影响显示逻辑）</li>\n<li>分离数据逻辑和表现逻辑(前后端耦合容易造成数据逻辑与表现逻辑混杂不清,这点在debug的时候尤其痛苦)</li>\n<li>展示类，管理类（CMS）项目强烈建议前后端分离</li>\n<li>前后端解耦方便维护（解耦有多重要就不多说了）。后端专注于提供数据，维护系统稳定，保证数据安全可靠（数据逻辑）。前端专注于交互和ui（表现逻辑）</li>\n<li>可以个APP端和web端提供统一的接口（同样的业务逻辑如果要写N遍，头疼，debug或加功能还要加N遍，心烦）</li>\n</ol>\n<h4 id=\"人员方面\"><a href=\"#人员方面\" class=\"headerlink\" title=\"人员方面\"></a>人员方面</h4><ol>\n<li>可以让每个员工变的更加专注，发挥TA自己最大的能力。前后端分离是为了更好的协作，在组织和流程上更加容易管理和达到更高的效率</li>\n<li>技术人员往往只能精通一个方面的技术（靠谱的全栈工程师还是少，或者说全栈工程师只是某个技术栈的全栈工程师）</li>\n</ol>\n<h4 id=\"综合方面\"><a href=\"#综合方面\" class=\"headerlink\" title=\"综合方面\"></a>综合方面</h4><ol>\n<li>前后端分离对人员和技术的要求更低</li>\n</ol>\n<p><strong>前后端分离是指技术架构上的分离，而不是组织/流程、职位/工种的分离</strong></p>\n"},{"title":"编程语言强类型、弱类型、静态类型、动态类型的区别","date":"2018-05-04T03:40:52.000Z","_content":"\n### 编程语言强类型、弱类型、静态类型、动态类型的区别\n之前一直没有好好了解编程语言类型的区别，现在来补补课。  \n\n引用一个轮子哥的回答，判断语言类型的区别如下\n>强类型：偏向于不容忍隐式类型转换。譬如说haskell的int就不能变成double\n>弱类型：偏向于容忍隐式类型转换。譬如说C语言的int可以变成double\n>静态类型：编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误。\n>动态类型：编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。譬如说你不能对一个数字a写a[10]当数组用。\n  \n上述引用可以作为一般的判断规则\n\n下面是主流编程语言的类型划分图  \n\n![Alt language](/images/programming_language.jpg)    \n\n**下面用javascript, python, java说明一下**\n先了解一个概念\n##### 类型安全\n>类型安全就是说，同一段内存，在不同的地方，会被强制要求使用相同的办法来解释（interpret）\n>类型安全代码只访问被授权可以访问的内存位置。\n\n#### 强类型和弱类型\n强弱类型是指语言类型系统对类型检查的严格程度。强类型语言指定了数据类型后，如果不经过强制类型转换，他将永远是这个数据类型。弱类型刚好相反，他允许编译器进行隐式类型转换。 不是类型安全的 \n**下面举2个例子**  \njavascript是弱类型语言，允许隐式类型转换，int类型的2会被转换成String类型的\"2\"，所以得到的a = \"12\"\n```javascript\nvar a = \"1\" + 2;\n```\n而python是强类型语言，不允许隐式类型转换。所以下面的代码会报错并提示类型错误。是类型安全的\n```python\na = \"1\" + 2\n\nTraceback (most recent call last):\n  File \"test.py\", line 1, in <module>\n    a = \"1\" + 2\nTypeError: must be str, not int\n```  \n\n#### 静态和动态类型\n动态类型在运行时才确定变量类型和执行类型检查，已python为例\n```python\n>>> a = 1\n>>> type(a)\n<type 'int'>\n>>> a = \"s\"\n>>> type(a)\n<type 'str'>\n```  \n静态语言在编译时就可以知道变量类型和执行类型检查，已java为例，在执行javac的时候就会报错，提示类型错误\n```java\nint a = \"a\";\n\nTest.java:3: 错误: 不兼容的类型: String无法转换为int\n        int a = \"a\";\n                ^\n1 个错误\n```  \n如果只是简单的了解一下编程语言强类型、弱类型、静态类型、动态类型的区别，读到这里就可以了。下面是关于编程语言强类型、弱类型、静态类型、动态类型区别的详细和深层次的分析，涉及一下比较专业的名词和知识。\n\n---\n（待续）\n\n发现一遍比较详细的文章可以读一下，[数据类型](http://linianhui.cnblogs.com/p/plp-04-datatypes.html \"数据类型\")  \n\n\n\n","source":"_posts/编程语言强类型、弱类型、静态类型、动态类型的区别.md","raw":"---\ntitle: 编程语言强类型、弱类型、静态类型、动态类型的区别\ndate: 2018-05-04 11:40:52\ntags:\n---\n\n### 编程语言强类型、弱类型、静态类型、动态类型的区别\n之前一直没有好好了解编程语言类型的区别，现在来补补课。  \n\n引用一个轮子哥的回答，判断语言类型的区别如下\n>强类型：偏向于不容忍隐式类型转换。譬如说haskell的int就不能变成double\n>弱类型：偏向于容忍隐式类型转换。譬如说C语言的int可以变成double\n>静态类型：编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误。\n>动态类型：编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。譬如说你不能对一个数字a写a[10]当数组用。\n  \n上述引用可以作为一般的判断规则\n\n下面是主流编程语言的类型划分图  \n\n![Alt language](/images/programming_language.jpg)    \n\n**下面用javascript, python, java说明一下**\n先了解一个概念\n##### 类型安全\n>类型安全就是说，同一段内存，在不同的地方，会被强制要求使用相同的办法来解释（interpret）\n>类型安全代码只访问被授权可以访问的内存位置。\n\n#### 强类型和弱类型\n强弱类型是指语言类型系统对类型检查的严格程度。强类型语言指定了数据类型后，如果不经过强制类型转换，他将永远是这个数据类型。弱类型刚好相反，他允许编译器进行隐式类型转换。 不是类型安全的 \n**下面举2个例子**  \njavascript是弱类型语言，允许隐式类型转换，int类型的2会被转换成String类型的\"2\"，所以得到的a = \"12\"\n```javascript\nvar a = \"1\" + 2;\n```\n而python是强类型语言，不允许隐式类型转换。所以下面的代码会报错并提示类型错误。是类型安全的\n```python\na = \"1\" + 2\n\nTraceback (most recent call last):\n  File \"test.py\", line 1, in <module>\n    a = \"1\" + 2\nTypeError: must be str, not int\n```  \n\n#### 静态和动态类型\n动态类型在运行时才确定变量类型和执行类型检查，已python为例\n```python\n>>> a = 1\n>>> type(a)\n<type 'int'>\n>>> a = \"s\"\n>>> type(a)\n<type 'str'>\n```  \n静态语言在编译时就可以知道变量类型和执行类型检查，已java为例，在执行javac的时候就会报错，提示类型错误\n```java\nint a = \"a\";\n\nTest.java:3: 错误: 不兼容的类型: String无法转换为int\n        int a = \"a\";\n                ^\n1 个错误\n```  \n如果只是简单的了解一下编程语言强类型、弱类型、静态类型、动态类型的区别，读到这里就可以了。下面是关于编程语言强类型、弱类型、静态类型、动态类型区别的详细和深层次的分析，涉及一下比较专业的名词和知识。\n\n---\n（待续）\n\n发现一遍比较详细的文章可以读一下，[数据类型](http://linianhui.cnblogs.com/p/plp-04-datatypes.html \"数据类型\")  \n\n\n\n","slug":"编程语言强类型、弱类型、静态类型、动态类型的区别","published":1,"updated":"2018-05-04T07:25:15.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhh3hh880009r4fj9c6zu1oj","content":"<h3 id=\"编程语言强类型、弱类型、静态类型、动态类型的区别\"><a href=\"#编程语言强类型、弱类型、静态类型、动态类型的区别\" class=\"headerlink\" title=\"编程语言强类型、弱类型、静态类型、动态类型的区别\"></a>编程语言强类型、弱类型、静态类型、动态类型的区别</h3><p>之前一直没有好好了解编程语言类型的区别，现在来补补课。  </p>\n<p>引用一个轮子哥的回答，判断语言类型的区别如下</p>\n<blockquote>\n<p>强类型：偏向于不容忍隐式类型转换。譬如说haskell的int就不能变成double<br>弱类型：偏向于容忍隐式类型转换。譬如说C语言的int可以变成double<br>静态类型：编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误。<br>动态类型：编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。譬如说你不能对一个数字a写a[10]当数组用。</p>\n</blockquote>\n<p>上述引用可以作为一般的判断规则</p>\n<p>下面是主流编程语言的类型划分图  </p>\n<p><img src=\"/images/programming_language.jpg\" alt=\"Alt language\">    </p>\n<p><strong>下面用javascript, python, java说明一下</strong><br>先了解一个概念</p>\n<h5 id=\"类型安全\"><a href=\"#类型安全\" class=\"headerlink\" title=\"类型安全\"></a>类型安全</h5><blockquote>\n<p>类型安全就是说，同一段内存，在不同的地方，会被强制要求使用相同的办法来解释（interpret）<br>类型安全代码只访问被授权可以访问的内存位置。</p>\n</blockquote>\n<h4 id=\"强类型和弱类型\"><a href=\"#强类型和弱类型\" class=\"headerlink\" title=\"强类型和弱类型\"></a>强类型和弱类型</h4><p>强弱类型是指语言类型系统对类型检查的严格程度。强类型语言指定了数据类型后，如果不经过强制类型转换，他将永远是这个数据类型。弱类型刚好相反，他允许编译器进行隐式类型转换。 不是类型安全的<br><strong>下面举2个例子</strong><br>javascript是弱类型语言，允许隐式类型转换，int类型的2会被转换成String类型的”2”，所以得到的a = “12”<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"1\"</span> + <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure></p>\n<p>而python是强类型语言，不允许隐式类型转换。所以下面的代码会报错并提示类型错误。是类型安全的</p>\n<pre><code class=\"python\">a = <span class=\"string\">\"1\"</span> + <span class=\"number\">2</span>\n\nTraceback (most recent call last):\n  File <span class=\"string\">\"test.py\"</span>, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span> &lt;module&gt;\n    a = <span class=\"string\">\"1\"</span> + <span class=\"number\">2</span>\nTypeError: must be str, <span class=\"keyword\">not</span> int\n</code></pre>\n<h4 id=\"静态和动态类型\"><a href=\"#静态和动态类型\" class=\"headerlink\" title=\"静态和动态类型\"></a>静态和动态类型</h4><p>动态类型在运行时才确定变量类型和执行类型检查，已python为例</p>\n<pre><code class=\"python\"><span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"number\">1</span>\n<span class=\"meta\">&gt;&gt;&gt; </span>type(a)\n&lt;type <span class=\"string\">'int'</span>&gt;\n<span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"string\">\"s\"</span>\n<span class=\"meta\">&gt;&gt;&gt; </span>type(a)\n&lt;type <span class=\"string\">'str'</span>&gt;\n</code></pre>\n<p>静态语言在编译时就可以知道变量类型和执行类型检查，已java为例，在执行javac的时候就会报错，提示类型错误</p>\n<pre><code class=\"java\"><span class=\"keyword\">int</span> a = <span class=\"string\">\"a\"</span>;\n\nTest.java:<span class=\"number\">3</span>: 错误: 不兼容的类型: String无法转换为<span class=\"keyword\">int</span>\n        <span class=\"keyword\">int</span> a = <span class=\"string\">\"a\"</span>;\n                ^\n<span class=\"number\">1</span> 个错误\n</code></pre>\n<p>如果只是简单的了解一下编程语言强类型、弱类型、静态类型、动态类型的区别，读到这里就可以了。下面是关于编程语言强类型、弱类型、静态类型、动态类型区别的详细和深层次的分析，涉及一下比较专业的名词和知识。</p>\n<hr>\n<p>（待续）</p>\n<p>发现一遍比较详细的文章可以读一下，<a href=\"http://linianhui.cnblogs.com/p/plp-04-datatypes.html\" title=\"数据类型\" target=\"_blank\" rel=\"noopener\">数据类型</a>  </p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"编程语言强类型、弱类型、静态类型、动态类型的区别\"><a href=\"#编程语言强类型、弱类型、静态类型、动态类型的区别\" class=\"headerlink\" title=\"编程语言强类型、弱类型、静态类型、动态类型的区别\"></a>编程语言强类型、弱类型、静态类型、动态类型的区别</h3><p>之前一直没有好好了解编程语言类型的区别，现在来补补课。  </p>\n<p>引用一个轮子哥的回答，判断语言类型的区别如下</p>\n<blockquote>\n<p>强类型：偏向于不容忍隐式类型转换。譬如说haskell的int就不能变成double<br>弱类型：偏向于容忍隐式类型转换。譬如说C语言的int可以变成double<br>静态类型：编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误。<br>动态类型：编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。譬如说你不能对一个数字a写a[10]当数组用。</p>\n</blockquote>\n<p>上述引用可以作为一般的判断规则</p>\n<p>下面是主流编程语言的类型划分图  </p>\n<p><img src=\"/images/programming_language.jpg\" alt=\"Alt language\">    </p>\n<p><strong>下面用javascript, python, java说明一下</strong><br>先了解一个概念</p>\n<h5 id=\"类型安全\"><a href=\"#类型安全\" class=\"headerlink\" title=\"类型安全\"></a>类型安全</h5><blockquote>\n<p>类型安全就是说，同一段内存，在不同的地方，会被强制要求使用相同的办法来解释（interpret）<br>类型安全代码只访问被授权可以访问的内存位置。</p>\n</blockquote>\n<h4 id=\"强类型和弱类型\"><a href=\"#强类型和弱类型\" class=\"headerlink\" title=\"强类型和弱类型\"></a>强类型和弱类型</h4><p>强弱类型是指语言类型系统对类型检查的严格程度。强类型语言指定了数据类型后，如果不经过强制类型转换，他将永远是这个数据类型。弱类型刚好相反，他允许编译器进行隐式类型转换。 不是类型安全的<br><strong>下面举2个例子</strong><br>javascript是弱类型语言，允许隐式类型转换，int类型的2会被转换成String类型的”2”，所以得到的a = “12”<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"1\"</span> + <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure></p>\n<p>而python是强类型语言，不允许隐式类型转换。所以下面的代码会报错并提示类型错误。是类型安全的</p>\n<pre><code class=\"python\">a = <span class=\"string\">\"1\"</span> + <span class=\"number\">2</span>\n\nTraceback (most recent call last):\n  File <span class=\"string\">\"test.py\"</span>, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span> &lt;module&gt;\n    a = <span class=\"string\">\"1\"</span> + <span class=\"number\">2</span>\nTypeError: must be str, <span class=\"keyword\">not</span> int\n</code></pre>\n<h4 id=\"静态和动态类型\"><a href=\"#静态和动态类型\" class=\"headerlink\" title=\"静态和动态类型\"></a>静态和动态类型</h4><p>动态类型在运行时才确定变量类型和执行类型检查，已python为例</p>\n<pre><code class=\"python\"><span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"number\">1</span>\n<span class=\"meta\">&gt;&gt;&gt; </span>type(a)\n&lt;type <span class=\"string\">'int'</span>&gt;\n<span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"string\">\"s\"</span>\n<span class=\"meta\">&gt;&gt;&gt; </span>type(a)\n&lt;type <span class=\"string\">'str'</span>&gt;\n</code></pre>\n<p>静态语言在编译时就可以知道变量类型和执行类型检查，已java为例，在执行javac的时候就会报错，提示类型错误</p>\n<pre><code class=\"java\"><span class=\"keyword\">int</span> a = <span class=\"string\">\"a\"</span>;\n\nTest.java:<span class=\"number\">3</span>: 错误: 不兼容的类型: String无法转换为<span class=\"keyword\">int</span>\n        <span class=\"keyword\">int</span> a = <span class=\"string\">\"a\"</span>;\n                ^\n<span class=\"number\">1</span> 个错误\n</code></pre>\n<p>如果只是简单的了解一下编程语言强类型、弱类型、静态类型、动态类型的区别，读到这里就可以了。下面是关于编程语言强类型、弱类型、静态类型、动态类型区别的详细和深层次的分析，涉及一下比较专业的名词和知识。</p>\n<hr>\n<p>（待续）</p>\n<p>发现一遍比较详细的文章可以读一下，<a href=\"http://linianhui.cnblogs.com/p/plp-04-datatypes.html\" title=\"数据类型\" target=\"_blank\" rel=\"noopener\">数据类型</a>  </p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}